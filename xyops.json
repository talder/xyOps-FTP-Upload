{
	"type": "xypdf",
	"description": "xyOps Portable Data Object",
	"version": "1.0",
	"xyops": "1.0.3",
	"items": [
		{
			"type": "plugin",
			"data": {
				"id": "ftp1toftp00001",
				"title": "FTP Upload",
				"enabled": true,
				"type": "event",
				"command": "pwsh",
				"script": "#requires -Version 7.0\n# Copyright (c) 2026 Tim Alderweireldt. All rights reserved.\n<#!\nxyOps FTP Upload Event Plugin (PowerShell 7)\nUpload files to remote servers via FTP, FTPS (Explicit/Implicit), or SFTP.\n\nProtocols:\n- FTP  : Plain FTP via .NET System.Net.FtpWebRequest (port 21)\n- FTPS : FTP over TLS — Explicit (STARTTLS, port 21) via .NET, Implicit (port 990) via TcpClient+SslStream\n- SFTP : SSH File Transfer Protocol via Posh-SSH module (port 22)\n\nI/O contract:\n- Read one JSON object from STDIN (job), write progress/messages as JSON lines of the\n  form: { \"xy\": 1, ... } to STDOUT.\n- On success, emit: { \"xy\": 1, \"code\": 0, \"data\": <result>, \"description\": \"...\" }\n- On error, emit:   { \"xy\": 1, \"code\": <nonzero>, \"description\": \"...\" } and exit 1.\n\nTest locally:\n  pwsh -NoProfile -ExecutionPolicy Bypass -File .\\ftp.ps1 < job.json\n#>\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n\n#region xyOps Output Helpers\n\nfunction Write-XY {\n  param([hashtable]$Object)\n  $payload = [ordered]@{ xy = 1 }\n  foreach ($k in $Object.Keys) { $payload[$k] = $Object[$k] }\n  [Console]::Out.WriteLine(($payload | ConvertTo-Json -Depth 20 -Compress))\n  [Console]::Out.Flush()\n}\n\nfunction Write-XYProgress {\n  param([double]$Value, [string]$Status)\n  $o = @{ progress = [math]::Round($Value, 4) }\n  if ($Status) { $o.status = $Status }\n  Write-XY $o\n}\n\nfunction Write-XYSuccess {\n  param($Data, [string]$Description)\n  $o = @{ code = 0; data = $Data }\n  if ($Description) { $o.description = $Description }\n  Write-XY $o\n}\n\nfunction Write-XYError {\n  param([int]$Code, [string]$Description)\n  Write-XY @{ code = $Code; description = $Description }\n}\n\nfunction Read-JobFromStdin {\n  $raw = [Console]::In.ReadToEnd()\n  if ([string]::IsNullOrWhiteSpace($raw)) { throw 'No job JSON received on STDIN' }\n  return $raw | ConvertFrom-Json -ErrorAction Stop\n}\n\nfunction Get-Param {\n  param($Params, [string]$Name, $Default = $null)\n  if ($Params.PSObject.Properties.Name -contains $Name) { return $Params.$Name }\n  return $Default\n}\n\nfunction Get-NestedValue {\n  param($Object, [string]$Path)\n  if (-not $Path -or ($Path.Trim() -eq '')) { return $Object }\n  $cur = $Object\n  foreach ($part in $Path.Split('.')) {\n    if ($null -eq $cur) { return $null }\n    if ($cur -is [System.Collections.IDictionary]) {\n      if (-not $cur.Contains($part)) { return $null }\n      $cur = $cur[$part]\n    }\n    else {\n      $cur = $cur.PSObject.Properties[$part].Value\n    }\n  }\n  return $cur\n}\n\n#endregion\n\n#region Module Installer\n\nfunction Install-RequiredModules {\n  param([string]$Protocol)\n\n  if ($Protocol -ne 'sftp') { return }\n\n  if (-not (Get-Module -ListAvailable -Name 'Posh-SSH')) {\n    Write-XYProgress 0.05 'Installing Posh-SSH module (first-time SFTP setup)...'\n    try {\n      Install-Module -Name 'Posh-SSH' -Scope CurrentUser -Force -AllowClobber -SkipPublisherCheck\n      Write-XYProgress 0.08 'Posh-SSH module installed successfully'\n    }\n    catch {\n      throw (\"Failed to install Posh-SSH module. Install manually: Install-Module -Name Posh-SSH -Scope CurrentUser -Force`n\" +\n             \"Error: $($_.Exception.Message)\")\n    }\n  }\n\n  Import-Module Posh-SSH -ErrorAction Stop\n}\n\n#endregion\n\n#region Error Handling\n\nfunction Format-TransferError {\n  param(\n    [System.Management.Automation.ErrorRecord]$ErrorRecord,\n    [string]$Phase,\n    [string]$Protocol\n  )\n\n  $msg = $ErrorRecord.Exception.Message\n  $innerMsg = if ($ErrorRecord.Exception.InnerException) { $ErrorRecord.Exception.InnerException.Message } else { '' }\n  $fullMsg = if ($innerMsg) { \"$msg — $innerMsg\" } else { $msg }\n\n  $category = 'Unknown'\n  $suggestion = ''\n\n  switch -Regex ($fullMsg) {\n    # Connection errors\n    'No such host|DNS|name.*resolution|could not resolve' {\n      $category = 'Connection — DNS Resolution'\n      $suggestion = 'Verify the hostname is correct and DNS is reachable'\n      break\n    }\n    'actively refused|connection refused|ECONNREFUSED' {\n      $category = 'Connection — Refused'\n      $suggestion = \"Verify the server is running and listening on the correct port for $Protocol\"\n      break\n    }\n    'timed? ?out|ETIMEDOUT' {\n      $category = 'Connection — Timeout'\n      $suggestion = 'Check firewall rules and network connectivity'\n      break\n    }\n    'unreachable|EHOSTUNREACH|ENETUNREACH' {\n      $category = 'Connection — Unreachable'\n      $suggestion = 'Verify network connectivity and routing to the server'\n      break\n    }\n    # Authentication errors\n    '530|not log|login.*fail|auth.*fail|invalid.*credential|access denied.*login|permission denied.*publickey' {\n      $category = 'Authentication — Failed'\n      $suggestion = 'Verify username/password or SSH key. Check if the account is active and not locked.'\n      break\n    }\n    'key.*invalid|key.*not.*found|private.*key|bad.*key|key.*format' {\n      $category = 'Authentication — SSH Key Error'\n      $suggestion = 'Verify the SSH key file exists, is readable, and in the correct format (RSA/ED25519/ECDSA/DSA)'\n      break\n    }\n    'passphrase|decrypt.*key' {\n      $category = 'Authentication — Key Passphrase'\n      $suggestion = 'The SSH key is encrypted. Provide the correct passphrase via parameter or FTP_SSH_KEY_PASSPHRASE secret.'\n      break\n    }\n    # Permission errors\n    '550.*permission|553|access.*denied|permission.*denied|not.*authorized' {\n      $category = 'Permission — Access Denied'\n      $suggestion = 'The user does not have write permission on the remote path. Check directory permissions on the server.'\n      break\n    }\n    '550.*no such|550.*not found|no such file|directory.*not.*exist' {\n      $category = 'Permission — Path Not Found'\n      $suggestion = 'The remote path does not exist. Enable \"Create Remote Directories\" or verify the path is correct.'\n      break\n    }\n    # Transfer errors\n    '552|disk.*full|no space|quota.*exceeded' {\n      $category = 'Transfer — Disk Full'\n      $suggestion = 'The remote server has insufficient disk space or the user quota is exceeded'\n      break\n    }\n    '451|transfer.*abort|upload.*fail|write.*fail' {\n      $category = 'Transfer — Failed'\n      $suggestion = 'The file transfer was interrupted. Check server logs and retry.'\n      break\n    }\n    # Protocol/TLS errors\n    'SSL|TLS|certificate|handshake|secure.*channel' {\n      $category = 'Protocol — TLS/SSL Error'\n      $suggestion = \"Check TLS configuration. For FTPS, verify the server supports the selected mode (Explicit/Implicit).\"\n      break\n    }\n    'STARTTLS|AUTH TLS' {\n      $category = 'Protocol — STARTTLS Failed'\n      $suggestion = 'The server does not support FTPS Explicit (STARTTLS). Try Implicit mode or plain FTP.'\n      break\n    }\n  }\n\n  if ($category -eq 'Unknown') {\n    $category = \"$Phase — Error\"\n    $suggestion = 'Check the error details and server configuration'\n  }\n\n  Write-XY @{ table = @{\n    title = 'Error Details'\n    header = @('Property', 'Value')\n    rows = @(\n      @('Category', $category),\n      @('Phase', $Phase),\n      @('Protocol', $Protocol.ToUpper()),\n      @('Details', $fullMsg),\n      @('Suggestion', $suggestion)\n    )\n    caption = ''\n  } }\n\n  return \"${category}: $fullMsg\"\n}\n\n#endregion\n\n#region FTP/FTPS Explicit Operations (.NET FtpWebRequest)\n\nfunction New-FTPRequest {\n  param(\n    [string]$Url,\n    [string]$Method,\n    [System.Net.NetworkCredential]$Credential,\n    [bool]$EnableSsl,\n    [bool]$PassiveMode\n  )\n\n  # Accept all server certificates for FTPS (common for internal/self-signed certs)\n  if ($EnableSsl) {\n    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { param($s, $c, $ch, $e) $true }\n  }\n\n  $request = [System.Net.FtpWebRequest]::Create($Url)\n  $request.Method = $Method\n  $request.Credentials = $Credential\n  $request.EnableSsl = $EnableSsl\n  $request.UsePassive = $PassiveMode\n  $request.UseBinary = $true\n  $request.KeepAlive = $false\n\n  return $request\n}\n\nfunction Get-FTPBaseUrl {\n  param([string]$HostName, [int]$Port)\n  return \"ftp://${HostName}:${Port}\"\n}\n\nfunction Test-FTPFileExists {\n  param(\n    [string]$BaseUrl,\n    [string]$RemoteFile,\n    [System.Net.NetworkCredential]$Credential,\n    [bool]$EnableSsl,\n    [bool]$PassiveMode\n  )\n\n  try {\n    $url = \"$BaseUrl/$($RemoteFile.TrimStart('/'))\"\n    $request = New-FTPRequest -Url $url -Method ([System.Net.WebRequestMethods+Ftp]::GetFileSize) `\n                              -Credential $Credential -EnableSsl $EnableSsl -PassiveMode $PassiveMode\n    $response = $request.GetResponse()\n    $size = $response.ContentLength\n    $response.Close()\n    return @{ Exists = $true; Size = $size }\n  }\n  catch {\n    return @{ Exists = $false; Size = 0 }\n  }\n}\n\nfunction New-FTPRemoteDirectory {\n  param(\n    [string]$BaseUrl,\n    [string]$DirPath,\n    [System.Net.NetworkCredential]$Credential,\n    [bool]$EnableSsl,\n    [bool]$PassiveMode\n  )\n\n  $parts = $DirPath.Split('/') | Where-Object { $_ }\n  $currentPath = ''\n\n  foreach ($part in $parts) {\n    $currentPath += \"/$part\"\n    try {\n      $url = \"$BaseUrl$currentPath/\"\n      $request = New-FTPRequest -Url $url -Method ([System.Net.WebRequestMethods+Ftp]::MakeDirectory) `\n                                -Credential $Credential -EnableSsl $EnableSsl -PassiveMode $PassiveMode\n      $response = $request.GetResponse()\n      $response.Close()\n    }\n    catch {\n      # Directory likely already exists — ignore 550 errors\n      if ($_.Exception.InnerException -and $_.Exception.InnerException.Message -notmatch '550') {\n        if ($_.Exception.Message -notmatch '550') { throw }\n      }\n    }\n  }\n}\n\nfunction Send-FTPSingleFile {\n  param(\n    [string]$BaseUrl,\n    [string]$RemoteFile,\n    [string]$LocalFilePath,\n    [System.Net.NetworkCredential]$Credential,\n    [bool]$EnableSsl,\n    [bool]$PassiveMode\n  )\n\n  $url = \"$BaseUrl/$($RemoteFile.TrimStart('/'))\"\n  $request = New-FTPRequest -Url $url -Method ([System.Net.WebRequestMethods+Ftp]::UploadFile) `\n                            -Credential $Credential -EnableSsl $EnableSsl -PassiveMode $PassiveMode\n\n  $fileBytes = [System.IO.File]::ReadAllBytes($LocalFilePath)\n  $stream = $request.GetRequestStream()\n  try {\n    $stream.Write($fileBytes, 0, $fileBytes.Length)\n  }\n  finally {\n    $stream.Close()\n  }\n\n  $response = $request.GetResponse()\n  $response.Close()\n\n  return $fileBytes.Length\n}\n\n#endregion\n\n#region FTPS Implicit Operations (TcpClient + SslStream)\n\nfunction Read-FTPSResponse {\n  param([System.IO.StreamReader]$Reader)\n\n  $line = $Reader.ReadLine()\n  if ($null -eq $line) { throw 'Connection closed by remote server' }\n\n  # Handle multi-line responses (e.g., \"220-Welcome\\r\\n220 Ready\")\n  while ($line -match '^\\d{3}-') {\n    $nextLine = $Reader.ReadLine()\n    if ($null -eq $nextLine) { break }\n    $line = $nextLine\n  }\n\n  $code = 0\n  $message = $line\n  if ($line -match '^(\\d{3})\\s?(.*)') {\n    $code = [int]$Matches[1]\n    $message = $Matches[2]\n  }\n\n  return @{ Code = $code; Text = $line; Message = $message }\n}\n\nfunction New-ImplicitFTPSSession {\n  param([string]$HostName, [int]$Port, [string]$Username, [string]$Password)\n\n  $tcpClient = [System.Net.Sockets.TcpClient]::new()\n  $tcpClient.Connect($HostName, $Port)\n\n  $sslCallback = [System.Net.Security.RemoteCertificateValidationCallback]{\n    param($sender, $certificate, $chain, $sslPolicyErrors)\n    return $true\n  }\n\n  $sslStream = [System.Net.Security.SslStream]::new(\n    $tcpClient.GetStream(), $false, $sslCallback\n  )\n  $sslStream.AuthenticateAsClient($HostName)\n\n  $reader = [System.IO.StreamReader]::new($sslStream, [System.Text.Encoding]::UTF8)\n  $writer = [System.IO.StreamWriter]::new($sslStream, [System.Text.Encoding]::UTF8)\n  $writer.AutoFlush = $true\n\n  # Read welcome banner\n  $resp = Read-FTPSResponse -Reader $reader\n  if ($resp.Code -ge 400) { throw \"Server rejected connection: $($resp.Text)\" }\n\n  # Login\n  $writer.WriteLine(\"USER $Username\")\n  $resp = Read-FTPSResponse -Reader $reader\n  if ($resp.Code -ge 400 -and $resp.Code -ne 331) { throw \"USER command failed: $($resp.Text)\" }\n\n  $writer.WriteLine(\"PASS $Password\")\n  $resp = Read-FTPSResponse -Reader $reader\n  if ($resp.Code -ge 400) { throw \"Authentication failed: $($resp.Text)\" }\n\n  # Binary mode\n  $writer.WriteLine(\"TYPE I\")\n  $null = Read-FTPSResponse -Reader $reader\n\n  # Set protection buffer size and data channel protection level for FTPS\n  $writer.WriteLine(\"PBSZ 0\")\n  $null = Read-FTPSResponse -Reader $reader\n\n  $writer.WriteLine(\"PROT P\")\n  $null = Read-FTPSResponse -Reader $reader\n\n  return @{\n    Client    = $tcpClient\n    SslStream = $sslStream\n    Reader    = $reader\n    Writer    = $writer\n    HostName  = $HostName\n  }\n}\n\nfunction Close-ImplicitFTPSSession {\n  param([hashtable]$Session)\n\n  try { $Session.Writer.WriteLine(\"QUIT\"); $null = Read-FTPSResponse -Reader $Session.Reader } catch {}\n  try { $Session.Reader.Dispose() } catch {}\n  try { $Session.Writer.Dispose() } catch {}\n  try { $Session.SslStream.Dispose() } catch {}\n  try { $Session.Client.Dispose() } catch {}\n}\n\nfunction Open-ImplicitFTPSDataChannel {\n  param([hashtable]$Session)\n\n  $Session.Writer.WriteLine(\"PASV\")\n  $resp = Read-FTPSResponse -Reader $Session.Reader\n\n  if ($resp.Text -match '\\((\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)\\)') {\n    $dataPort = [int]$Matches[5] * 256 + [int]$Matches[6]\n  }\n  else {\n    throw \"Failed to parse PASV response: $($resp.Text)\"\n  }\n\n  $dataClient = [System.Net.Sockets.TcpClient]::new()\n  $dataClient.Connect($Session.HostName, $dataPort)\n\n  $sslCallback = [System.Net.Security.RemoteCertificateValidationCallback]{\n    param($sender, $certificate, $chain, $sslPolicyErrors)\n    return $true\n  }\n\n  $dataSsl = [System.Net.Security.SslStream]::new(\n    $dataClient.GetStream(), $false, $sslCallback\n  )\n  $dataSsl.AuthenticateAsClient($Session.HostName)\n\n  return @{ Client = $dataClient; SslStream = $dataSsl }\n}\n\nfunction New-ImplicitFTPSDirectory {\n  param([hashtable]$Session, [string]$DirPath)\n\n  $parts = $DirPath.Split('/') | Where-Object { $_ }\n  $currentPath = ''\n\n  foreach ($part in $parts) {\n    $currentPath += \"/$part\"\n    $Session.Writer.WriteLine(\"MKD $currentPath\")\n    $null = Read-FTPSResponse -Reader $Session.Reader   # Ignore errors if dir already exists\n  }\n}\n\nfunction Test-ImplicitFTPSFileExists {\n  param([hashtable]$Session, [string]$RemoteFile)\n\n  $Session.Writer.WriteLine(\"SIZE $RemoteFile\")\n  $resp = Read-FTPSResponse -Reader $Session.Reader\n\n  if ($resp.Code -eq 213) {\n    $size = 0\n    if ($resp.Message -match '(\\d+)') { $size = [long]$Matches[1] }\n    return @{ Exists = $true; Size = $size }\n  }\n  return @{ Exists = $false; Size = 0 }\n}\n\nfunction Send-ImplicitFTPSSingleFile {\n  param([hashtable]$Session, [string]$RemoteFile, [string]$LocalFilePath)\n\n  $dataChannel = Open-ImplicitFTPSDataChannel -Session $Session\n\n  $fileBytes = [System.IO.File]::ReadAllBytes($LocalFilePath)\n\n  try {\n    $Session.Writer.WriteLine(\"STOR $RemoteFile\")\n    $resp = Read-FTPSResponse -Reader $Session.Reader\n    if ($resp.Code -ge 400) { throw \"STOR command failed: $($resp.Text)\" }\n\n    $dataChannel.SslStream.Write($fileBytes, 0, $fileBytes.Length)\n    $dataChannel.SslStream.Flush()\n  }\n  finally {\n    try { $dataChannel.SslStream.Close() } catch {}\n    try { $dataChannel.Client.Close() } catch {}\n  }\n\n  # Read transfer complete response\n  $resp = Read-FTPSResponse -Reader $Session.Reader\n\n  return $fileBytes.Length\n}\n\n#endregion\n\n#region SFTP Operations (Posh-SSH)\n\nfunction New-SFTPConnection {\n  param(\n    [string]$HostName,\n    [int]$Port,\n    [string]$Username,\n    [string]$Password,\n    [string]$KeyPath,\n    [string]$KeyPassphrase\n  )\n\n  # Build credential — for key auth, the credential password is used as the key passphrase\n  $securePass = if ($KeyPath -and $KeyPassphrase) {\n    ConvertTo-SecureString $KeyPassphrase -AsPlainText -Force\n  }\n  elseif ($Password) {\n    ConvertTo-SecureString $Password -AsPlainText -Force\n  }\n  else {\n    [System.Security.SecureString]::new()\n  }\n\n  $credential = [System.Management.Automation.PSCredential]::new($Username, $securePass)\n\n  $sessionParams = @{\n    ComputerName = $HostName\n    Port         = $Port\n    Credential   = $credential\n    AcceptKey    = $true\n    Force        = $true\n    ErrorAction  = 'Stop'\n  }\n\n  if ($KeyPath) {\n    if (-not (Test-Path $KeyPath)) {\n      throw \"SSH key file not found: $KeyPath\"\n    }\n    $sessionParams['KeyFile'] = $KeyPath\n  }\n\n  $session = New-SFTPSession @sessionParams\n  return $session\n}\n\nfunction Test-SFTPFileExists {\n  param([int]$SessionId, [string]$RemotePath)\n\n  try {\n    $item = Get-SFTPItem -SessionId $SessionId -Path $RemotePath -ErrorAction Stop\n    return @{ Exists = $true; Size = $item.Length }\n  }\n  catch {\n    return @{ Exists = $false; Size = 0 }\n  }\n}\n\nfunction New-SFTPRemoteDirectory {\n  param([int]$SessionId, [string]$DirPath)\n\n  $parts = $DirPath.Split('/') | Where-Object { $_ }\n  $currentPath = ''\n\n  foreach ($part in $parts) {\n    $currentPath += \"/$part\"\n    if (-not (Test-SFTPPath -SessionId $SessionId -Path $currentPath)) {\n      New-SFTPItem -SessionId $SessionId -Path $currentPath -ItemType Directory -ErrorAction Stop | Out-Null\n    }\n  }\n}\n\nfunction Send-SFTPSingleFile {\n  param(\n    [int]$SessionId,\n    [string]$LocalFilePath,\n    [string]$RemoteDir,\n    [bool]$Overwrite\n  )\n\n  $destDir = $RemoteDir.TrimEnd('/') + '/'\n\n  $params = @{\n    SessionId   = $SessionId\n    Path        = $LocalFilePath\n    Destination = $destDir\n    ErrorAction = 'Stop'\n  }\n  if ($Overwrite) { $params['Force'] = $true }\n\n  Set-SFTPItem @params\n\n  return (Get-Item $LocalFilePath).Length\n}\n\nfunction Close-SFTPConnection {\n  param([int]$SessionId)\n\n  try { Remove-SFTPSession -SessionId $SessionId -ErrorAction SilentlyContinue | Out-Null } catch {}\n}\n\n#endregion\n\n#region File Resolution\n\nfunction Resolve-UploadFiles {\n  param($Params, $JobInput, [string]$Cwd)\n\n  $fileSource = (Get-Param $Params 'fileSource' 'local').ToLower()\n  $files = [System.Collections.ArrayList]::new()\n\n  switch ($fileSource) {\n    'local' {\n      $localPath = Get-Param $Params 'localPath' ''\n      if (-not $localPath) { throw 'Local Path is required when File Source is \"Local file or folder\"' }\n\n      if ($localPath -match '[\\*\\?]') {\n        # Glob pattern\n        $resolved = @(Get-ChildItem -Path $localPath -File -ErrorAction SilentlyContinue)\n        if ($resolved.Count -eq 0) {\n          throw \"No files found matching pattern: $localPath\"\n        }\n        foreach ($item in $resolved) {\n          $null = $files.Add(@{\n            LocalPath  = $item.FullName\n            RemoteName = $item.Name\n            TempFile   = $false\n            Size       = $item.Length\n          })\n        }\n      }\n      elseif (Test-Path $localPath -PathType Container) {\n        # Directory — upload all files recursively\n        $items = @(Get-ChildItem -Path $localPath -Recurse -File)\n        if ($items.Count -eq 0) { throw \"No files found in directory: $localPath\" }\n        $basePath = (Resolve-Path $localPath).Path\n        foreach ($item in $items) {\n          $relativePath = $item.FullName.Substring($basePath.Length).TrimStart([IO.Path]::DirectorySeparatorChar).Replace('\\', '/')\n          $null = $files.Add(@{\n            LocalPath  = $item.FullName\n            RemoteName = $relativePath\n            TempFile   = $false\n            Size       = $item.Length\n          })\n        }\n      }\n      elseif (Test-Path $localPath -PathType Leaf) {\n        # Single file\n        $item = Get-Item $localPath\n        $null = $files.Add(@{\n          LocalPath  = $item.FullName\n          RemoteName = $item.Name\n          TempFile   = $false\n          Size       = $item.Length\n        })\n      }\n      else {\n        throw \"File or folder not found: $localPath\"\n      }\n    }\n\n    'content' {\n      $content  = Get-Param $Params 'content' ''\n      $fileName = Get-Param $Params 'contentFileName' 'upload.txt'\n      if (-not $content) { throw 'Content is required when File Source is \"Raw text content\"' }\n      if (-not $fileName) { $fileName = 'upload.txt' }\n\n      $tempFile = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), $fileName)\n      [System.IO.File]::WriteAllText($tempFile, $content, [System.Text.Encoding]::UTF8)\n\n      $null = $files.Add(@{\n        LocalPath  = $tempFile\n        RemoteName = $fileName\n        TempFile   = $true\n        Size       = (Get-Item $tempFile).Length\n      })\n    }\n\n    'jobdata' {\n      $dataPath = Get-Param $Params 'dataPath' ''\n      $fileName = Get-Param $Params 'dataFileName' 'upload.txt'\n      if (-not $JobInput) { throw 'No input data available from previous job' }\n\n      $inputData = if ($JobInput.PSObject.Properties.Name -contains 'data') { $JobInput.data } else { $JobInput }\n      $value = Get-NestedValue $inputData $dataPath\n\n      if ($null -eq $value) { throw \"No data found at path '$dataPath' in previous job output\" }\n\n      $content = if ($value -is [string]) { $value } else { $value | ConvertTo-Json -Depth 20 }\n      if (-not $fileName) { $fileName = 'upload.txt' }\n\n      $tempFile = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), $fileName)\n      [System.IO.File]::WriteAllText($tempFile, $content, [System.Text.Encoding]::UTF8)\n\n      $null = $files.Add(@{\n        LocalPath  = $tempFile\n        RemoteName = $fileName\n        TempFile   = $true\n        Size       = (Get-Item $tempFile).Length\n      })\n    }\n\n    'jobfiles' {\n      if (-not $JobInput) { throw 'No input available from previous job' }\n\n      $inputFiles = if ($JobInput.PSObject.Properties.Name -contains 'files') { $JobInput.files } else { $null }\n      if (-not $inputFiles -or $inputFiles.Count -eq 0) {\n        throw 'No files found in previous job output. The previous event plugin must emit files via Write-XY @{ files = $files }.'\n      }\n\n      # xyOps pre-downloads files from the previous workflow step into CWD\n      $baseDir = if ($Cwd -and (Test-Path $Cwd -PathType Container)) {\n        $Cwd\n      } else {\n        (Get-Location).Path\n      }\n\n      foreach ($inputFile in $inputFiles) {\n        $fileName = if ($inputFile -is [string]) { $inputFile } else { $inputFile.filename }\n        if (-not $fileName) { continue }\n\n        $localPath = [System.IO.Path]::Combine($baseDir, $fileName)\n\n        if (-not (Test-Path $localPath -PathType Leaf)) {\n          throw \"Previous job file not found: $fileName. File not found at: $localPath\"\n        }\n\n        $item = Get-Item $localPath\n        $null = $files.Add(@{\n          LocalPath  = $item.FullName\n          RemoteName = $item.Name\n          TempFile   = $false\n          Size       = $item.Length\n        })\n      }\n    }\n\n    default {\n      throw \"Unknown file source: $fileSource. Expected: local, content, jobdata, or jobfiles.\"\n    }\n  }\n\n  return $files.ToArray()\n}\n\n#endregion\n\n#region Main Orchestrator\n\nfunction Invoke-FTPUpload {\n  param($Params, $JobInput, [string]$Cwd)\n\n  Write-XYProgress 0.02 'Starting FTP Upload...'\n\n  # ── Resolve parameters with secret vault fallback ──────────────────────\n  $protocol = (Get-Param $Params 'protocol' 'ftp').ToLower()\n\n  $ftpHost = (Get-Param $Params 'host' '').Trim()\n  if (-not $ftpHost) { $ftpHost = if ($env:FTP_HOST) { $env:FTP_HOST.Trim() } else { '' } }\n\n  $portStr = (Get-Param $Params 'port' '').ToString().Trim()\n  if (-not $portStr) { $portStr = if ($env:FTP_PORT) { $env:FTP_PORT.Trim() } else { '' } }\n\n  $username = (Get-Param $Params 'username' '').Trim()\n  if (-not $username) { $username = if ($env:FTP_USERNAME) { $env:FTP_USERNAME.Trim() } else { '' } }\n\n  $password = (Get-Param $Params 'password' '').Trim()\n  if (-not $password) { $password = if ($env:FTP_PASSWORD) { $env:FTP_PASSWORD.Trim() } else { '' } }\n\n  $ftpsMode = (Get-Param $Params 'ftpsMode' 'explicit').ToLower()\n\n  $sshKeyPath = (Get-Param $Params 'sshKeyPath' '').Trim()\n  if (-not $sshKeyPath) { $sshKeyPath = if ($env:FTP_SSH_KEY_PATH) { $env:FTP_SSH_KEY_PATH.Trim() } else { '' } }\n\n  $sshKeyPassphrase = (Get-Param $Params 'sshKeyPassphrase' '').Trim()\n  if (-not $sshKeyPassphrase) { $sshKeyPassphrase = if ($env:FTP_SSH_KEY_PASSPHRASE) { $env:FTP_SSH_KEY_PASSPHRASE.Trim() } else { '' } }\n\n  $remotePath   = (Get-Param $Params 'remotePath' '').Trim().TrimEnd('/')\n  $createDirs   = if ($Params.PSObject.Properties.Name -contains 'createRemoteDirs') { [bool]$Params.createRemoteDirs } else { $true }\n  $ifFileExists = (Get-Param $Params 'ifFileExists' 'overwrite').ToLower()\n  $passiveMode  = if ($Params.PSObject.Properties.Name -contains 'passiveMode') { [bool]$Params.passiveMode } else { $true }\n\n  # ── Auto-detect port ───────────────────────────────────────────────────\n  $port = 0\n  if ($portStr -and $portStr -match '^\\d+$') {\n    $port = [int]$portStr\n  }\n  else {\n    $port = switch ($protocol) {\n      'ftp'  { 21 }\n      'ftps' { if ($ftpsMode -eq 'implicit') { 990 } else { 21 } }\n      'sftp' { 22 }\n      default { 21 }\n    }\n  }\n\n  # ── Validation ─────────────────────────────────────────────────────────\n  Write-XYProgress 0.04 'Validating parameters...'\n\n  if (-not $ftpHost)    { throw 'Host is required. Provide it as a parameter or configure the FTP_HOST secret in the vault.' }\n  if (-not $username)   { throw 'Username is required. Provide it as a parameter or configure the FTP_USERNAME secret in the vault.' }\n  if (-not $remotePath) { throw 'Remote Path is required.' }\n\n  if ($protocol -eq 'sftp' -and -not $password -and -not $sshKeyPath) {\n    throw 'SFTP requires either a password or an SSH key. Provide a password or configure FTP_SSH_KEY_PATH.'\n  }\n  if ($protocol -ne 'sftp' -and -not $password) {\n    throw 'Password is required for FTP/FTPS. Provide it as a parameter or configure the FTP_PASSWORD secret in the vault.'\n  }\n\n  # ── Display configuration ──────────────────────────────────────────────\n  $authMethod = switch ($protocol) {\n    'sftp' { if ($sshKeyPath) { \"SSH Key ($sshKeyPath)\" } else { 'Password' } }\n    default { 'Password' }\n  }\n  $protocolDesc = switch ($protocol) {\n    'ftp'  { 'FTP (Plain)' }\n    'ftps' { \"FTPS ($( ($ftpsMode.Substring(0,1).ToUpper() + $ftpsMode.Substring(1)) ) TLS)\" }\n    'sftp' { 'SFTP (SSH)' }\n  }\n\n  Write-XY @{ table = @{\n    title  = 'Configuration'\n    header = @('Setting', 'Value')\n    rows   = @(\n      @('Protocol', $protocolDesc),\n      @('Host', $ftpHost),\n      @('Port', $port),\n      @('Username', $username),\n      @('Auth Method', $authMethod),\n      @('Remote Path', $remotePath),\n      @('Create Remote Dirs', $(if ($createDirs) { 'Yes' } else { 'No' })),\n      @('If File Exists', ($ifFileExists.Substring(0,1).ToUpper() + $ifFileExists.Substring(1))),\n      @('Passive Mode', $(if ($passiveMode) { 'Yes' } else { 'N/A (SFTP)' }))\n    )\n    caption = ''\n  } }\n\n  # ── Install required modules ───────────────────────────────────────────\n  Install-RequiredModules -Protocol $protocol\n\n  # ── Resolve files to upload ────────────────────────────────────────────\n  Write-XYProgress 0.10 'Resolving files to upload...'\n  $filesToUpload = @(Resolve-UploadFiles -Params $Params -JobInput $JobInput -Cwd $Cwd)\n\n  Write-XY @{ table = @{\n    title  = 'Files to Upload'\n    header = @('#', 'File', 'Size')\n    rows   = @(\n      $filesToUpload | ForEach-Object -Begin { $i = 0 } -Process {\n        $i++\n        ,@($i, $_.RemoteName, \"$( '{0:N0}' -f $_.Size ) bytes\")\n      }\n    )\n    caption = \"$($filesToUpload.Count) file(s) ready for upload\"\n  } }\n\n  # ── Connect and upload ─────────────────────────────────────────────────\n  $results       = [System.Collections.ArrayList]::new()\n  $totalSize     = [long]0\n  $skippedCount  = 0\n  $uploadedCount = 0\n  $ftpSession    = $null\n  $sftpSession   = $null\n\n  try {\n    Write-XYProgress 0.15 \"Connecting to ${ftpHost}:${port} via $($protocol.ToUpper())...\"\n\n    # ── SFTP path ──────────────────────────────────────────────────────\n    if ($protocol -eq 'sftp') {\n\n      $sftpSession = New-SFTPConnection -HostName $ftpHost -Port $port -Username $username `\n                                        -Password $password -KeyPath $sshKeyPath -KeyPassphrase $sshKeyPassphrase\n      $sessionId = $sftpSession.SessionId\n\n      Write-XYProgress 0.20 'Connected via SFTP'\n\n      if ($createDirs) {\n        Write-XYProgress 0.22 \"Creating remote directory: $remotePath\"\n        New-SFTPRemoteDirectory -SessionId $sessionId -DirPath $remotePath\n      }\n\n      $fileIndex = 0\n      foreach ($file in $filesToUpload) {\n        $fileIndex++\n        $progress = 0.25 + (0.65 * ($fileIndex / $filesToUpload.Count))\n        $remoteFile = \"$remotePath/$($file.RemoteName)\"\n        $remoteDir  = $remotePath\n\n        # Handle subdirectories in remote name (e.g., folder uploads)\n        if ($file.RemoteName -match '/') {\n          $remoteDir = \"$remotePath/$( [System.IO.Path]::GetDirectoryName($file.RemoteName).Replace('\\', '/') )\"\n          if ($createDirs) { New-SFTPRemoteDirectory -SessionId $sessionId -DirPath $remoteDir }\n        }\n\n        Write-XYProgress $progress \"Uploading ($fileIndex/$($filesToUpload.Count)): $($file.RemoteName)\"\n\n        # Check file existence\n        if ($ifFileExists -ne 'overwrite') {\n          $existsCheck = Test-SFTPFileExists -SessionId $sessionId -RemotePath $remoteFile\n          if ($existsCheck.Exists) {\n            if ($ifFileExists -eq 'skip') {\n              $skippedCount++\n              $null = $results.Add(@{ name = $file.RemoteName; remotePath = $remoteFile; size = $file.Size; status = 'skipped' })\n              continue\n            }\n            elseif ($ifFileExists -eq 'error') {\n              throw \"File already exists on remote server: $remoteFile\"\n            }\n          }\n        }\n\n        $uploadSize = Send-SFTPSingleFile -SessionId $sessionId -LocalFilePath $file.LocalPath `\n                                          -RemoteDir $remoteDir -Overwrite ($ifFileExists -eq 'overwrite')\n        $totalSize += $uploadSize\n        $uploadedCount++\n        $null = $results.Add(@{ name = $file.RemoteName; remotePath = $remoteFile; size = $uploadSize; status = 'uploaded' })\n      }\n    }\n\n    # ── FTPS Implicit path ─────────────────────────────────────────────\n    elseif ($protocol -eq 'ftps' -and $ftpsMode -eq 'implicit') {\n\n      $ftpSession = New-ImplicitFTPSSession -HostName $ftpHost -Port $port -Username $username -Password $password\n\n      Write-XYProgress 0.20 'Connected via FTPS (Implicit TLS)'\n\n      if ($createDirs) {\n        Write-XYProgress 0.22 \"Creating remote directory: $remotePath\"\n        New-ImplicitFTPSDirectory -Session $ftpSession -DirPath $remotePath\n      }\n\n      $fileIndex = 0\n      foreach ($file in $filesToUpload) {\n        $fileIndex++\n        $progress = 0.25 + (0.65 * ($fileIndex / $filesToUpload.Count))\n        $remoteFile = \"$remotePath/$($file.RemoteName)\"\n\n        # Handle subdirectories in remote name\n        if ($file.RemoteName -match '/') {\n          $subDir = \"$remotePath/$( [System.IO.Path]::GetDirectoryName($file.RemoteName).Replace('\\', '/') )\"\n          if ($createDirs) { New-ImplicitFTPSDirectory -Session $ftpSession -DirPath $subDir }\n        }\n\n        Write-XYProgress $progress \"Uploading ($fileIndex/$($filesToUpload.Count)): $($file.RemoteName)\"\n\n        # Check file existence\n        if ($ifFileExists -ne 'overwrite') {\n          $existsCheck = Test-ImplicitFTPSFileExists -Session $ftpSession -RemoteFile $remoteFile\n          if ($existsCheck.Exists) {\n            if ($ifFileExists -eq 'skip') {\n              $skippedCount++\n              $null = $results.Add(@{ name = $file.RemoteName; remotePath = $remoteFile; size = $file.Size; status = 'skipped' })\n              continue\n            }\n            elseif ($ifFileExists -eq 'error') {\n              throw \"File already exists on remote server: $remoteFile\"\n            }\n          }\n        }\n\n        $uploadSize = Send-ImplicitFTPSSingleFile -Session $ftpSession -RemoteFile $remoteFile -LocalFilePath $file.LocalPath\n        $totalSize += $uploadSize\n        $uploadedCount++\n        $null = $results.Add(@{ name = $file.RemoteName; remotePath = $remoteFile; size = $uploadSize; status = 'uploaded' })\n      }\n    }\n\n    # ── FTP / FTPS Explicit path ───────────────────────────────────────\n    else {\n\n      $enableSsl  = ($protocol -eq 'ftps')\n      $credential = [System.Net.NetworkCredential]::new($username, $password)\n      $baseUrl    = Get-FTPBaseUrl -HostName $ftpHost -Port $port\n\n      Write-XYProgress 0.20 \"Connected via $($protocol.ToUpper())$(if ($enableSsl) { ' (Explicit TLS)' } else { '' })\"\n\n      if ($createDirs) {\n        Write-XYProgress 0.22 \"Creating remote directory: $remotePath\"\n        New-FTPRemoteDirectory -BaseUrl $baseUrl -DirPath $remotePath -Credential $credential `\n                               -EnableSsl $enableSsl -PassiveMode $passiveMode\n      }\n\n      $fileIndex = 0\n      foreach ($file in $filesToUpload) {\n        $fileIndex++\n        $progress = 0.25 + (0.65 * ($fileIndex / $filesToUpload.Count))\n        $remoteFile = \"$remotePath/$($file.RemoteName)\"\n\n        # Handle subdirectories in remote name\n        if ($file.RemoteName -match '/') {\n          $subDir = \"$remotePath/$( [System.IO.Path]::GetDirectoryName($file.RemoteName).Replace('\\', '/') )\"\n          if ($createDirs) {\n            New-FTPRemoteDirectory -BaseUrl $baseUrl -DirPath $subDir -Credential $credential `\n                                   -EnableSsl $enableSsl -PassiveMode $passiveMode\n          }\n        }\n\n        Write-XYProgress $progress \"Uploading ($fileIndex/$($filesToUpload.Count)): $($file.RemoteName)\"\n\n        # Check file existence\n        if ($ifFileExists -ne 'overwrite') {\n          $existsCheck = Test-FTPFileExists -BaseUrl $baseUrl -RemoteFile $remoteFile -Credential $credential `\n                                            -EnableSsl $enableSsl -PassiveMode $passiveMode\n          if ($existsCheck.Exists) {\n            if ($ifFileExists -eq 'skip') {\n              $skippedCount++\n              $null = $results.Add(@{ name = $file.RemoteName; remotePath = $remoteFile; size = $file.Size; status = 'skipped' })\n              continue\n            }\n            elseif ($ifFileExists -eq 'error') {\n              throw \"File already exists on remote server: $remoteFile\"\n            }\n          }\n        }\n\n        $uploadSize = Send-FTPSingleFile -BaseUrl $baseUrl -RemoteFile $remoteFile -LocalFilePath $file.LocalPath `\n                                         -Credential $credential -EnableSsl $enableSsl -PassiveMode $passiveMode\n        $totalSize += $uploadSize\n        $uploadedCount++\n        $null = $results.Add(@{ name = $file.RemoteName; remotePath = $remoteFile; size = $uploadSize; status = 'uploaded' })\n      }\n    }\n\n    # ── Display results ──────────────────────────────────────────────────\n    Write-XYProgress 0.95 'Upload complete'\n\n    $resultRows = @($results | ForEach-Object -Begin { $i = 0 } -Process {\n      $i++\n      $statusIcon = switch ($_.status) { 'uploaded' { 'Uploaded' }; 'skipped' { 'Skipped' }; default { $_.status } }\n      ,@($i, $_.name, \"$( '{0:N0}' -f $_.size ) bytes\", $statusIcon)\n    })\n\n    Write-XY @{ table = @{\n      title   = 'Upload Results'\n      header  = @('#', 'File', 'Size', 'Status')\n      rows    = $resultRows\n      caption = \"$uploadedCount uploaded, $skippedCount skipped, $( '{0:N0}' -f $totalSize ) bytes total\"\n    } }\n\n    # ── Build output data ────────────────────────────────────────────────\n    return [pscustomobject]@{\n      tool         = 'ftpUpload'\n      success      = $true\n      protocol     = $protocol\n      host         = $ftpHost\n      port         = $port\n      remotePath   = $remotePath\n      files        = @($results)\n      totalFiles   = $uploadedCount\n      totalSize    = $totalSize\n      skippedFiles = $skippedCount\n      timestamp    = [datetime]::UtcNow.ToString('o')\n    }\n  }\n  catch {\n    # Categorised error handling\n    $phase = switch -Regex ($_.Exception.Message) {\n      'resolv|DNS|refused|timeout|unreachable|connect' { 'Connection'; break }\n      'auth|login|credential|key.*invalid|passphrase'  { 'Authentication'; break }\n      'permission|denied|550|553'                      { 'Permission'; break }\n      'SSL|TLS|certificate|handshake'                  { 'Protocol'; break }\n      default                                          { 'Transfer' }\n    }\n\n    $errorMsg = Format-TransferError -ErrorRecord $_ -Phase $phase -Protocol $protocol\n    throw $errorMsg\n  }\n  finally {\n    # Cleanup connections\n    if ($ftpSession)  { Close-ImplicitFTPSSession -Session $ftpSession }\n    if ($sftpSession) { Close-SFTPConnection -SessionId $sftpSession.SessionId }\n\n    # Cleanup temp files\n    foreach ($file in $filesToUpload) {\n      if ($file.TempFile -and (Test-Path $file.LocalPath)) {\n        Remove-Item $file.LocalPath -Force -ErrorAction SilentlyContinue\n      }\n    }\n  }\n}\n\n#endregion\n\n#region Main Entry Point\n\ntry {\n  $job    = Read-JobFromStdin\n  $Params = $job.params\n\n  # Event plugin STDIN: cwd and input are top-level properties\n  $Cwd = if ($job.PSObject.Properties.Name -contains 'cwd') { $job.cwd } else { $null }\n\n  # Resolve job input from the previous workflow step\n  $JobInput = $null\n  if ($job.PSObject.Properties.Name -contains 'input') {\n    $JobInput = $job.input\n  }\n  # Fallback: top-level \"data\" / \"files\" (for local testing)\n  if (-not $JobInput) {\n    $hasData  = $job.PSObject.Properties.Name -contains 'data'\n    $hasFiles = $job.PSObject.Properties.Name -contains 'files'\n    if ($hasData -or $hasFiles) {\n      $JobInput = [PSCustomObject]@{\n        data  = if ($hasData)  { $job.data }  else { $null }\n        files = if ($hasFiles) { $job.files } else { @() }\n      }\n    }\n  }\n\n  if ($Cwd -and (Test-Path $Cwd -PathType Container)) { Set-Location $Cwd }\n\n  $result = Invoke-FTPUpload -Params $Params -JobInput $JobInput -Cwd $Cwd\n  Write-XYSuccess -Data $result -Description \"Uploaded $($result.totalFiles) file(s) via $($result.protocol.ToUpper()) to $($result.host)\"\n  exit 0\n}\ncatch {\n  Write-XYError -Code 1 -Description $_.Exception.Message\n  exit 1\n}\n\n#endregion",
				"scriptFile": "ftp.ps1",
				"groups": [],
				"format": "",
				"params": [
					{
						"id": "protocol",
						"title": "Protocol",
						"type": "select",
						"caption": "Transfer protocol to use",
						"locked": false,
						"value": "FTP — Plain FTP [ftp], FTPS — FTP over TLS/SSL [ftps], SFTP — SSH File Transfer [sftp]"
					},
					{
						"id": "host",
						"title": "Host",
						"type": "text",
						"caption": "Server hostname or IP address. Overrides FTP_HOST secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "port",
						"title": "Port",
						"type": "text",
						"caption": "Server port. Leave empty for auto-detect (21 for FTP/FTPS Explicit, 990 for FTPS Implicit, 22 for SFTP). Overrides FTP_PORT secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "username",
						"title": "Username",
						"type": "text",
						"caption": "FTP/SFTP username. Overrides FTP_USERNAME secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "password",
						"title": "Password",
						"type": "text",
						"caption": "FTP/SFTP password. Overrides FTP_PASSWORD secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "ftpsMode",
						"title": "FTPS Mode",
						"type": "select",
						"caption": "TLS mode for FTPS connections (only applies when Protocol is FTPS)",
						"locked": false,
						"value": "Explicit — STARTTLS on port 21 [explicit], Implicit — Direct TLS on port 990 [implicit]"
					},
					{
						"id": "sshKeyPath",
						"title": "SSH Key Path",
						"type": "text",
						"caption": "Path to SSH private key file (SFTP only). Supports RSA, ED25519, ECDSA, DSA. Overrides FTP_SSH_KEY_PATH secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "sshKeyPassphrase",
						"title": "SSH Key Passphrase",
						"type": "text",
						"caption": "Passphrase for encrypted SSH private key (SFTP only). Overrides FTP_SSH_KEY_PASSPHRASE secret.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "remotePath",
						"title": "Remote Path",
						"type": "text",
						"caption": "Destination directory on the remote server (e.g., /uploads/reports)",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": true
					},
					{
						"id": "fileSource",
						"title": "File Source",
						"type": "select",
						"caption": "Where to get the file(s) to upload",
						"locked": false,
						"value": "Local file or folder [local], Raw text content [content], Previous job output data [jobdata], Previous job files [jobfiles]"
					},
					{
						"id": "localPath",
						"title": "Local Path",
						"type": "text",
						"caption": "File or folder path to upload. Supports glob patterns (e.g., /tmp/*.csv). Used when File Source is 'Local file or folder'.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "content",
						"title": "Content",
						"type": "code",
						"caption": "Raw text content to upload as a file. Used when File Source is 'Raw text content'.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "contentFileName",
						"title": "Content File Name",
						"type": "text",
						"caption": "Filename for the raw content upload (e.g., report.csv, config.json). Required when File Source is 'Raw text content'.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "dataPath",
						"title": "Data Path",
						"type": "text",
						"caption": "Dot-notation path to content in previous job output data (e.g., data.content, data.report). Used when File Source is 'Previous job output'.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "dataFileName",
						"title": "Data File Name",
						"type": "text",
						"caption": "Filename for content from previous job (e.g., export.csv). Used when File Source is 'Previous job output'.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "createRemoteDirs",
						"title": "Create Remote Directories",
						"type": "checkbox",
						"caption": "Automatically create remote directories if they don't exist",
						"locked": false,
						"value": true
					},
					{
						"id": "ifFileExists",
						"title": "If File Exists",
						"type": "select",
						"caption": "What to do when a file already exists on the remote server",
						"locked": false,
						"value": "Overwrite [overwrite], Skip [skip], Error [error]"
					},
					{
						"id": "passiveMode",
						"title": "Passive Mode",
						"type": "checkbox",
						"caption": "Use passive mode for FTP/FTPS connections (recommended for most firewalls and NAT setups)",
						"locked": false,
						"value": true
					}
				],
				"notes": "",
				"icon": "upload",
				"uid": "",
				"gid": "",
				"kill": "none",
				"runner": false
			}
		}
	]
}
